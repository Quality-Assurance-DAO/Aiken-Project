// Oracle signature verification logic for milestone verification

use aiken/builtin.{Address, ByteArray, Int, List}

/// Oracle signature record
pub type OracleSignature {
  oracle_address: Address
  signature_hash: ByteArray
  signed_data: ByteArray
  signature_timestamp: Int
}

/// Filter signatures to only those from authorized oracle addresses
pub fn filter_authorized_signatures(
  signatures: List<OracleSignature>,
  authorized_addresses: List<Address>
) -> List<OracleSignature> {
  list.filter(signatures, fn(sig) {
    list.any(authorized_addresses, fn(addr) { addr == sig.oracle_address })
  })
}

/// Remove duplicate oracle signatures (keep first occurrence of each oracle address)
pub fn remove_duplicate_oracles(
  signatures: List<OracleSignature>
) -> List<OracleSignature> {
  // Keep first occurrence of each oracle address
  list.fold(signatures, [], fn(acc, sig) {
    let is_duplicate = list.any(acc, fn(existing) {
      existing.oracle_address == sig.oracle_address
    })
    when is_duplicate {
      True -> acc
      False -> list.append(acc, [sig])
    }
  })
}

/// Count valid oracle signatures after filtering and deduplication
pub fn count_valid_signatures(
  signatures: List<OracleSignature>,
  authorized_addresses: List<Address>
) -> Int {
  let filtered = filter_authorized_signatures(signatures, authorized_addresses)
  let unique = remove_duplicate_oracles(filtered)
  list.length(unique)
}




